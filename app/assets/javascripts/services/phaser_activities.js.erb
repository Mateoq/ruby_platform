'use strict';
prServices.factory('graphicService', ['$rootScope', '$route', '$timeout', function($rootScope, $route, $timeout){
	var service, graphicBars, pictogram;

	service = function (options, game, done, callback) {
		service.data = options;
		service.game = game;

        service.game.state.add('boot', service.boot);
		service.game.state.start('boot');

		service.totalCounter = 0;
		service.done = done;
		service.updateUserProgress = callback;
	};

    service.methods = [ "graphicBars", "pictogram" ];

	service.boot = {
        init: function (){

            if (service.data.hasOwnProperty('maxWidth')) {
                service.game.scale.scaleMode = Phaser.ScaleManager.SHOW_ALL;
//              service.game.scale.setScreenSize(true);
                service.game.scale.refresh();
                service.game.scale.setMinMax(300, service.data.maxHeight, service.data.maxWidth, service.data.maxHeight);
            }
        },
        create: function (){
            var method = service.methods[service.data.method];
            service.game.state.add(method, service[method]);
            service.game.state.start(method);
        }
    };

	service.graphicBars = {
		positions: null,
		positions2: null,
		corte: [],
		tween: [],
		bars: [],
		btn: [],
		media: false,
        resetProperties: function (){
            this.positions = null;
            this.positions2 = null;
            this.corte = [];
            this.tween = [];
            this.bars = [];
            this.btn = [];
            this.media = false;
        },
		preload: function (){
            this.resetProperties();
			service.game.renderer.resize(service.data.width, service.data.height);
			service.game.load.atlasJSONArray('atlas', service.data.atlasPath, null, service.data.atlasJson);
            this.media = service.data.media;

            if (!service.data.buttons) {
                this.positions = service.data.bars;

                if (this.media) {
                	this.positions2 = service.data.medias;
                	this.tween2 = [];
                 	this.corte2 = [];
                 	this.line = null; this.corteLinea = null;
                	this.animarLinea = null; this.bars2 = [];
            	}
            } else {
                this.positions = service.data.buttons;
                this.positions2 = service.data.bars;
            }
		},
		create: function (){
            var self = this;
			service.game.add.image(0,0, 'atlas','bg');
			
			for (var i = 0; i < this.positions.length; i++) {
				this.bars[i] = (service.data.buttons) ? service.game.add.sprite(this.positions2[i].x, this.positions2[i].y,'atlas', this.positions2[i].name)
											: service.game.add.sprite(this.positions[i].x, this.positions[i].y,'atlas', this.positions[i].name);

                if (service.data.horizontal) {
                    this.bars[i].anchor.setTo(0,0.5);
                    this.bars[i].visible = false;
                    this.corte[i] = new Phaser.Rectangle(0,0,0,this.bars[i].height);
                    this.tween[i] = service.game.add.tween(this.corte[i]).to({width: this.bars[i].width},500,Phaser.Easing.Linear.Out,false,0,0,false);
                } else {
                    this.bars[i].anchor.setTo(0.5,1);
                    this.bars[i].visible = false;
                    this.corte[i] = new Phaser.Rectangle(0, 0, this.bars[i].width, 0);
                    this.tween[i] = service.game.add.tween(this.corte[i]).to({height: this.bars[i].height}, 1000, Phaser.Easing.Linear.Out, false, 0, 0, false);
                }

				if (!this.media && this.positions2) {
//                    this.btn[i] = service.game.add.button(this.positions[i].x, this.positions[i].y,'atlas',function (button){
//						var b = this.btn.indexOf(button);
//						this.animacion(this.bars[b], this.corte[b], this.tween[b]);
//					},this, this.positions[i].btn, this.positions[i].btn);
//					this.btn[i].input.useHandCursor = true;

                    this.btn[i] = service.game.add.sprite(this.positions[i].x, this.positions[i].y,'atlas', this.positions[i].btn);
                    this.btn[i].inputEnabled = true;
                    this.btn[i].input.useHandCursor = true;
                    this.btn[i].events.onInputDown.add(function (button){
                        var b = self.btn.indexOf(button);
                        self.animacion(self.bars[b], self.corte[b], self.tween[b]);
                    }, this);

				}
			}

			if (this.media) {
				for (var c = 0; c < this.positions2.length; c++) {
					this.bars2[c] = service.game.add.sprite(this.positions2[c].x, this.positions2[c].y,'atlas',this.positions2[c].name);
					this.bars2[c].visible = false;

					this.corte2[c] = new Phaser.Rectangle(0,0,this.bars2[c].width,0);
					this.tween2[c] = service.game.add.tween(this.corte2[c]).to({height:this.bars2[c].height}, 1000, Phaser.Easing.Linear.Out, false, 0, 0, false);
				}

				this.bars2[0].anchor.setTo(0.5,0);
				this.bars2[1].anchor.setTo(0.5,1);
				this.bars2[2].anchor.setTo(0.5,0);

				this.line = service.game.add.sprite(99,121,'atlas','line');
				this.line.visible = false;
				this.corteLinea = new Phaser.Rectangle(0,0,0,this.line.height);
				this.animarLinea = service.game.add.tween(this.corteLinea).to({width:this.line.width},1000,Phaser.Easing.Linear.In,false,0,0,false);
			}

			if (service.done) {
				if (!this.media && this.positions2) {
					for (var i = 0; i < this.bars.length; i++) {
	    				this.animacion(this.bars[i], this.corte[i], this.tween[i]);
	            	}

	            	return;
				}
				this.animacion();
				return;
			}

			if (!service.data.buttons) {
				service.game.input.onDown.add(this.animacion, this);
			}

		},
		animacion: function (bar, corte, tween){
			if (!this.positions2 || this.media) {
				for (var i = 0; i < this.bars.length; i++) {
					if (this.bars[i].visible) { continue; }
					service.totalCounter++;
					this.bars[i].visible = true;
					this.bars[i].crop(this.corte[i]);
					this.tween[i].start();
					
					if (this.media) 
						this.tween[i]._lastChild.onComplete.add(this.linea,this);
				}
			} else {
				if (bar.visible) { return; }
				service.totalCounter++;
				bar.visible = true;
				tween.start(0);
				bar.crop(corte);
			}

			if (this.bars.length != service.totalCounter || service.done || angular.isUndefined(service.updateUserProgress)) { return; }

			service.updateUserProgress();
		},
		update: function (){
			for (var i = 0; i < this.bars.length; i++) {
				this.bars[i].updateCrop();
			}

			if (this.media) {
				for (var c = 0; c < this.positions2.length; c++) {
					this.bars2[c].updateCrop();
				}

				this.line.updateCrop();
			}
		},
		linea : function(){
			this.line.visible = true;
			this.line.crop(this.corteLinea);
			this.animarLinea.start();
			this.animarLinea.onComplete.addOnce(this.animacionSalida,this);
		},
		animacionSalida : function(){
			for (var i = 0; i < 3; i++) {
				this.bars2[i].visible = true;
				this.bars2[i].crop(this.corte2[i]);
				this.tween2[i].start();
			}
		}
	};

	service.pictogram = {
		pos: null,
		dias: [],
		barras: [],
		corte: [],
		anim: [],
		n: null,
		grupo: [],
		resetProperties: function () {
			this.pos = null;
			this.dthisias = [];
			this.barras = [];
			this.corte = [];
			this.anim = [];
			this.n = null;
			this.grupo = [];
		},
		preload: function (){
			this.resetProperties();
			this.pos = service.data.positions;
			service.game.load.atlasJSONArray('atlas', service.data.atlasPath, null, service.data.atlasJson);
		},
		create: function (){
			var self = this;
			for (var i = 0; i < 7; i++) {
				this.barras[i] = service.game.add.sprite(0, this.pos[i].y,'atlas', 'barra');
				this.barras[i].visible = false;
				// barras[i].anchor.setTo(0.5,1);
				this.dias[i] = service.game.add.sprite(0,this.pos[i].y, 'atlas',this.pos[i].dia);
				this.dias[i].inputEnabled = true;
				this.dias[i].input.useHandCursor = true;
				this.dias[i].events.onInputDown.add(function (button) {
					var index = this.dias.indexOf(button);	
					this.n = index;
					this.barra(this.barras[index], this.anim[index], this.corte[index]);
				},this);
				this.corte[i] = new Phaser.Rectangle(0, 0, 0, this.barras[i].height);
				this.anim[i] = service.game.add.tween(this.corte[i]).to({width: this.barras[i].width}, 1000, Phaser.Easing.Linear.Out,false, 0,0,false);
				this.grupo[i] = service.game.add.group();
				this.grupo[i].alpha = 0;
			}

			if (service.done) {
				for (var j = 0; j < this.barras.length; j++) {
					this.barra(this.barras[j], this.anim[j], this.corte[j], j);
				}
			}
		},
		update: function (){
			for (var i = 0; i < this.barras.length; i++) {
				this.barras[i].updateCrop();
			}
		},
		barra: function (barra, anim, corte, index){
			if (barra.visible) { return; }

			for (var i = 0; i < this.dias.length; i++) {
				this.dias[i].inputEnabled = false;
				this.dias[i].input.useHandCursor = false;
			}

			service.totalCounter++;

			barra.visible = true;
			barra.crop(corte);
			if (service.done) {
				var self = this;
				$timeout(function () {
					self.otra(index);					
				}, 800);
			} else {
				anim.onComplete.add(this.otra,this);
			}
			anim.start(0);

			if (this.barras.length != service.totalCounter || service.done || angular.isUndefined(service.updateUserProgress)) { return; }


			service.updateUserProgress();
		},
		otra: function (index){
			var pos2 = service.data.positions2,
				p = service.data.itemsPositions;

			var n = (service.done) ? index : this.n;

			for (var i = 0; i < p[n].times; i++) {
				this.grupo[n].create(pos2[i].x, p[n].first, 'atlas', 'pre');
				service.game.add.tween(this.grupo[n]).to({alpha:1}, 800, Phaser.Easing.Linear.None, true,0,0,false).delay(1000);	
			}

			for (var i = 0; i < this.dias.length; i++) {
				this.dias[i].inputEnabled = true;
				this.dias[i].input.useHandCursor = true;
			}
		}
	};

	return service;
}]);

prServices.factory('dragNDropService', function(){
	var service;

	service = function (options, game, done, callback) {
		service.data = options;
		service.game = game;
		service.assetPositions = service.data.assetPositions;

		service.drops = service.data.drops;
		service.drags = service.data.drags;
		// var method = service.methods[service.data.method];
		service.game.state.add('dragNDropButtons', service.dragNDropButtons);
		service.game.state.start('dragNDropButtons');

		// validation
		service.done = done;
		service.rightAnswers = 0;
		service.totalCounter = 0;
		service.updateUserProgress = callback;
	};

	service.dragNDropButtons = {
		right: [], wrong: [], arrows: [], dropItems: [], dragItems: [], staticAssets: [], rightAnswers: 0, assetKeys: [],
        count: 0,
		init: function () {
			// service.game.renderer.resize(service.data.width, service.data.height);
			// service.game.scale.scaleMode = Phaser.ScaleManager.SHOW_ALL;
			// service.game.scale.setScreenSize(true);
			// service.game.scale.refresh();	
		},
		preload: function () {
			this.resetProperties();
			service.game.load.atlasJSONArray('atlas', service.data.atlasPath, null, service.data.atlasJson);	
		},
		create: function () {
			// Load Assets
			var staticText, answer, textStyles;
			for (var j = 0; j < service.assetPositions.length; j++) {
				this.staticAssets[j] = service.game.add.sprite(service.assetPositions[j].x, service.assetPositions[j].y, 'atlas', service.assetPositions[j].name);

				if (service.assetPositions[j].hasOwnProperty('text')) {
					textStyles = service.data.textStyles;
					staticText = service.game.add.text(service.assetPositions[j].text.x,
							service.assetPositions[j].text.y,
							service.assetPositions[j].text.text
						);

					staticText.updateText();

					angular.forEach(service.data.textStyles, function (value, key) {
						if ('wordWrapWidth' === key)
							staticText.wordWrap = true;
						staticText[key] = value;
					});

					staticText.font = 'Open Sans';

					if (service.data.textStyles.hasOwnProperty('fontSize'))
						staticText.fontSize = service.data.textStyles.fontSize;

					if (service.data.textStyles.hasOwnProperty('fontWeight'))
						staticText.fontWeight = service.data.textStyles.fontWeight;

					if (service.data.textStyles.hasOwnProperty('wrap')) {
						staticText.wordWrap = true;
						staticText.wordWrapWidth = service.data.textStyles.wrap;
					}

					this.staticAssets[j].addChild(staticText);
				}

				if (service.assetPositions[j].hasOwnProperty('answer')) {

					this.assetKeys.push(j);

					answer = service.game.add.text(service.assetPositions[j].answer.x,
							service.assetPositions[j].answer.y,
							service.assetPositions[j].answer.answer
						);
					answer.updateText();

					angular.forEach(service.data.answerStyles, function (value, key) {
						if ('wordWrapWidth' === key)
							answer.wordWrap = true;
						answer[key] = value;
					});

					answer.font = 'Open Sans';

					if (!service.done) {
						answer.alpha = 0;
					}

					this.staticAssets[j].addChild(answer);
				}

				if (service.assetPositions[j].hasOwnProperty('icons')) {
					this.arrows[j] = service.game.add.sprite(service.assetPositions[j].icons.x, service.assetPositions[j].icons.y, 'atlas', 'icon_arrow');
					console.log(this.arrows);
				}

				// If asset contains an image
				if (angular.isDefined(service.assetPositions[j].contentImage)) {

					var dropImage = service.assetPositions[j].contentImage,
						contentImage = service.game.add.sprite(dropImage.x, dropImage.y, 'atlas', dropImage.name);

					this.staticAssets[j].addChild(contentImage);
				}
			}

			if (service.done) { return; }

			// Load Objects
			var drag, text, h, w;
			for (var i = 0; i < service.drops.length; i++) {
				// Load Wrong and Right icons
				this.right[i] = service.game.add.sprite(0, 0,'atlas', 'icon_right');
				this.right[i].alpha = 0;
				this.wrong[i] = service.game.add.sprite(0,0, 'atlas','icon_wrong');
				this.wrong[i].alpha = 0;

				// Load Drop location items
				this.dropItems[i] = service.game.add.sprite(service.drops[i].x, service.drops[i].y, 'atlas', service.drops[i].name);
				service.drops[i].chances = 2;

				// If drop item contains an image
				if (angular.isDefined(service.drops[i].contentImage)) {
					var dropContainerImage = service.drops[i].contentImage,
						dropsContentImage = service.game.add.sprite(dropContainerImage.x, dropContainerImage.y, 'atlas', dropContainerImage.name);

					this.dropItems[i].addChild(dropsContentImage);
				}
			}

			// Load Draggable items
			var dragGroups;
			for (var k = 0; k < service.drags.length; k++) {
				this.dragItems[k] = service.game.add.sprite(service.drags[k].x, service.drags[k].y, 'atlas', service.drags[k].name);

				dragGroups = service.game.add.group(this.dragItems[k]);

				if (service.drags[k].hasOwnProperty('text')) {

					text = service.game.add.text(service.data.dragsData.x,
								service.data.dragsData.y,
								service.drags[k].text.text,
								service.data.dragsData.styles
					);

					text.updateText();

					if (service.data.dragsData.hasOwnProperty('wrap')) {
						text.wordWrap = true
						text.wordWrapWidth = service.data.dragsData.wrap;
					}

					text.x = this.dragItems[k].width / 2 - (text.width / 2);
					text.y = this.dragItems[k].height / 2 - (text.height / 2);

					dragGroups.add(text);
				}

				this.dragItems[k].scale.set(0.9, 0.9);
				this.dragItems[k].inputEnabled = true;
                this.dragItems[k].input.useHandCursor = true;
				this.dragItems[k].input.enableDrag();
				this.dragItems[k].events.onDragStart.add(this.onDragStart, this);
				this.dragItems[k].events.onDragStop.add(this.onValidateDrop, this);
			}
		},
		onDragStart: function (sprite) {
			sprite.scale.setTo(1, 1);
		},
		onValidateDrop: function (sprite) {
			sprite.scale.setTo(0.9,0.9);

			var index = this.dragItems.indexOf(sprite),
				drag = service.drags[index],
				validated = false;

			for (var i = 0; i < this.dropItems.length; i++) {
				if (false === sprite.overlap(this.dropItems[i])) { continue; }

				if (0 === service.drops[i].chances) break;

				validated = true;

				var indexAsset = this.assetKeys[i],
					asset = service.assetPositions[indexAsset];

				this.arrows[indexAsset].alpha = 0;

				if (drag.value === asset.answer.answer || drag.value === asset.answer.value) {
					service.totalCounter++;
					service.rightAnswers++;
					if (drag.hasOwnProperty('text')) {
						// this.staticAssets[indexAsset].children[0].alpha = 1;
						service.game.add.tween(this.staticAssets[indexAsset].children[0]).to({ alpha: 1 }, 300, Phaser.Easing.Linear.In, true);
						service.game.add.tween(sprite).to({ alpha: 0 }, 200, Phaser.Easing.Linear.Out, true, 0, 0, true)
													.to({ alpha: 0 }, 200, Phaser.Easing.Linear.Out, true, 0, 0, false);
					} else {
						service.game.add.tween(sprite).to({x: asset.finalPosition.x, y: asset.finalPosition.y}, 200, Phaser.Easing.Linear.Out, false);

						if (angular.isDefined(asset.scale)) {
							service.game.add.tween(sprite.scale).to({x: asset.scale.x, y: asset.scale.y}, 200, Phaser.Easing.Elastic.Out, false);
						}
					}

					service.game.add.tween(this.dropItems[i]).to({ alpha: 0 }, 200, Phaser.Easing.Linear.Out, true, 0, 0, false);
					sprite.inputEnabled = false;
					this.right[i].reset(asset.icons.x, asset.icons.y);
					service.game.add.tween(this.right[i]).to({ alpha: 1 }, 200, Phaser.Easing.Linear.Out, true, 100, 4, true);
					service.drops[i].chances = 0;
					this.rightAnswers++;
					break;
				} else {
					
					service.drops[i].chances--;

					this.wrong[i].reset(asset.icons.x, asset.icons.y);

					var wrongTween = service.game.add.tween(this.wrong[i]).to({ alpha: 1 }, 200, Phaser.Easing.Linear.Out, true, 0, 4, true),
						self = this;

					if (0 === service.drops[i].chances) {
						service.totalCounter++;
						service.game.add.tween(this.dropItems[i]).to({ alpha: 0 }, 200, Phaser.Easing.Linear.Out, true, 0, 0, false);
						// this.staticAssets[indexAsset].children[1].alpha = 1;
						service.game.add.tween(this.staticAssets[indexAsset].children[0]).to({ alpha: 1 }, 300, Phaser.Easing.Linear.In, true);
						service.game.add.tween(sprite).to({ x: drag.x, y: drag.y }, 200, Phaser.Easing.Linear.Out, true);
						break;
					}

					wrongTween.to({ alpha: 0 }, 200, Phaser.Easing.Linear.Out, true, 100, 0, false);
					wrongTween.onComplete.add(function () {
						service.game.time.events.add(200, function () {
							self.arrows[indexAsset].alpha = 1;
						}, self);
						
					}, this);
					service.game.add.tween(sprite).to({ x: drag.x, y: drag.y }, 200, Phaser.Easing.Linear.Out, true);

					break;
				}

            }

			if (!validated) {
				service.game.add.tween(sprite).to({ x: drag.x, y: drag.y }, 200, Phaser.Easing.Linear.Out, true);
			}

            if (service.drops.length != service.totalCounter || service.done) { return; }

            service.updateUserProgress(service.totalCounter, service.rightAnswers);
		},
		resetProperties: function () {
			this.right = []; this.wrong =  []; this.arrows = []; this.dropItems = [];
			this.dragItems = []; this.staticAssets = []; this.rightAnswers = 0;
			this.assetKeys = [];
		}
	};

	return service;
});

prServices.factory('pairsActivityService', function(){
	var service;

	service = function (options, game, done, callback) {
		service.data = options;
		service.game = game;

		// Activity objects
		service.assetPositions = service.data.assetPositions;
		service.helperHandlers = service.data.helperHandlers;
		service.eventHandlers = service.data.eventHandlers;
		service.answerObjects = service.data.answerObjects;


		// Load states
		service.game.state.add('pairsLines', service.pairsLines);
		service.game.state.start('pairsLines');

		// validation
		service.done = done;
		service.rightAnswers = 0;
		service.totalCounter = 0;
		service.updateUserProgress = callback;
	};

	service.pairsLines = {
		right: [], wrong: [], arrows: [], staticAssets: [], rightAnswers: 0, count: 0, assetKeys: [],
		helperHandler: [], eventHandler: [], answerObject: [], lines: [], isPairing: false, handlerIndex: null,
		init: function () {
			
		},
		resetProperties: function () {
			this.right = []; this.wrong =  []; this.arrows = [];
			this.staticAssets = []; this.rightAnswers = 0; this.assetKeys = [];
		},
		preload: function () {
			this.resetProperties();
			service.game.load.atlasJSONArray('atlas', service.data.atlasPath, null, service.data.atlasJson);	
		},
		create: function () {
			// Load static assets
			for (var j = 0; j < service.assetPositions.length; j++) {
				this.staticAssets[j] = service.game.add.sprite(service.assetPositions[j].x, service.assetPositions[j].y, 'atlas', service.assetPositions[j].name);

				if (service.assetPositions[j].hasOwnProperty('text')) {
					textStyles = service.data.textStyles;
					staticText = service.game.add.text(service.assetPositions[j].text.x,
							service.assetPositions[j].text.y,
							service.assetPositions[j].text.text
						);

					staticText.updateText();

					angular.forEach(service.data.textStyles, function (value, key) {
						if ('wordWrapWidth' === key)
							staticText.wordWrap = true;
						staticText[key] = value;
					});

					staticText.font = 'Open Sans';

					if (service.data.textStyles.hasOwnProperty('fontSize'))
						staticText.fontSize = service.data.textStyles.fontSize;

					if (service.data.textStyles.hasOwnProperty('fontWeight'))
						staticText.fontWeight = service.data.textStyles.fontWeight;

					if (service.data.textStyles.hasOwnProperty('wrap')) {
						staticText.wordWrap = true;
						staticText.wordWrapWidth = service.data.textStyles.wrap;
					}

					this.staticAssets[j].addChild(staticText);
				}

				// if (service.assetPositions[j].hasOwnProperty('answer')) {

				// 	this.assetKeys.push(j);

				// 	answer = service.game.add.text(service.assetPositions[j].answer.x,
				// 			service.assetPositions[j].answer.y,
				// 			service.assetPositions[j].answer.answer
				// 		);
				// 	answer.updateText();

				// 	angular.forEach(service.data.answerStyles, function (value, key) {
				// 		if ('wordWrapWidth' === key)
				// 			answer.wordWrap = true;
				// 		answer[key] = value;
				// 	});

				// 	answer.font = 'Open Sans';

				// 	if (!service.done) {
				// 		answer.alpha = 0;
				// 	}

				// 	this.staticAssets[j].addChild(answer);
				// }

				if (service.assetPositions[j].hasOwnProperty('icons')) {
					this.assetKeys.push(j);
					this.arrows[j] = service.game.add.sprite(service.assetPositions[j].icons.x, service.assetPositions[j].icons.y, 'atlas', 'icon_arrow');
				}

				// If asset contains an image
				if (angular.isDefined(service.assetPositions[j].contentImage)) {

					var imageData = service.assetPositions[j].contentImage,
						contentImage = service.game.add.sprite(imageData.x, imageData.y, 'atlas', imageData.name);

					this.staticAssets[j].addChild(contentImage);
				}
			}

			// Load helper handlers, event handlers and answer objects
			for (var i = 0; i < service.helperHandlers.length; i++) {
				// Helper handlers
				this.helperHandler[i] = service.game.add.sprite(service.helperHandlers[i].x, service.helperHandlers[i].y, 'atlas', service.helperHandlers[i].name);
				this.helperHandler[i].anchor.setTo(0.5);

				// Answer objects
				this.answerObject[i] = service.game.add.sprite(service.answerObjects[i].x, service.answerObjects[i].y, 'atlas', service.answerObjects[i].name);
				this.answerObject[i].anchor.setTo(0.5);
				this.answerObject[i].value = service.answerObjects.value;

				// Event handlers
				this.eventHandler[i] = service.game.add.sprite(service.eventHandlers[i].x, service.eventHandlers[i].y, 'atlas', service.eventHandlers[i].name);
				this.eventHandler[i].anchor.setTo(0.5);
				this.eventHandler[i].inputEnabled = true;
				this.eventHandler[i].input.enableDrag(true);
				this.eventHandler[i].value = service.eventHandlers[i].value;
				this.eventHandler[i].bringToTop();
				this.eventHandler[i].events.onInputDown.add(this.onPair, this);

				// Add phisics
				service.game.physics.enable(this.eventHandler[i], Phaser.Physics.ARCADE);

				// Load lines
				this.lines[i] = new Phaser.Line(service.helperHandlers[i].x, service.helperHandlers[i].y, service.eventHandlers[i].x,service.eventHandlers[i].y);
			}
		},
		update: function() {
			for (var i = 0; i < this.eventHandler.length; i++) {
				this.lines[i].fromSprite(this.helperHandler[i], this.eventHandler[i], false);
			}

			if (null === this.handlerIndex) { return; }

			if (this.isPairing === true) {
				this.eventHandler[this.handlerIndex].loadTexture('atlas', service.eventHandlers[handlerIndex].activeName, 0, true);
				service.game.physics.arcade.moveToPointer(this.eventHandler[this.handlerIndex], 350);
				if (Phaser.Rectangle.contains(this.eventHandler[this.handlerIndex].body, service.game.input.x, service.game.input.y)) {
					this.eventHandler[this.handlerIndex].body.velocity.setTo(0,0);
				}
			} else {
				this.eventHandler[this.handlerIndex].loadTexture('atlas', service.eventHandlers[handlerIndex].name, 0, true);
				this.eventHandler[this.handlerIndex].body.velocity.setTo(0,0);
			}
		},
		render: function(){
			for (var i = 0; i < this.lines.length; i++) {
				service.game.debug.geom(this.lines[i], service.data.linesColor);
			}
		},
		loadHandlerFinalPosition: function (index) {
			this.eventHandler[index].input.enableDrag(false);
			this.eventHandler[index].inputEnabled = false;
			this.eventHandler[index].reset(service.eventHandlers[index].answer.x, service.eventHandlers[index].answer.y);
		},
		onPair: function (sprite) {
			var index = this.eventHandler.indexOf(sprite),
				handler = service.eventHandlers[index];
				objectAnswer = null, objectAnswerIndex = -1,
				indexAsset = null,
				asset = null;

			this.handlerIndex = index;

			if (this.isPairing) { this.isPairing = !this.isPairing; return; }

			this.isPairing = !this.isPairing;

			for (var i = 0; i < this.answerObject.length; i++) {
				if (!sprite.overlap(this.answerObject[i])) { continue; }

				if (0 === service.answerObjects[i].chances) { break; }

				objectAnswer = this.answerObject[i];
				objectAnswerIndex = i;

				indexAsset = this.assetKeys[i];
				asset = service.assetPositions[indexAsset];
				break;
			}

			if (null === objectAnswer) {
				this.eventHandler[index].input.enableDrag(false);
				this.eventHandler[index].reset(service.eventHandlers[index].x,service.eventHandlers[index].y);
				service.game.add.tween(sprite).to({ x: drag.x, y: drag.y }, 200, Phaser.Easing.Linear.Out, true);

				return;
			}

			if (sprite.value === objectAnswer.value) {
				service.totalCounter++;
				service.rightAnswers++;

				this.loadHandlerFinalPosition(index);

				this.right[indexAsset].reset(asset.icons.x, asset.icons.y);
				service.game.add.tween(this.right[indexAsset]).to({ alpha: 1 }, 200, Phaser.Easing.Linear.Out, true, 100, 4, true);
				service.answerObjects[objectAnswerIndex].chances = 0;
			} else {
				service.answerObjects[objectAnswerIndex].chances--;

				this.wrong[i].reset(asset.icons.x, asset.icons.y);

				var wrongTween = service.game.add.tween(this.wrong[i]).to({ alpha: 1 }, 200, Phaser.Easing.Linear.Out, true, 0, 4, true),
					self = this;

				if (0 === service.answerObjects[objectAnswerIndex].chances) {
					service.totalCounter++;
					service.game.add.tween(sprite).to({ x: handler.x, y: handler.y }, 200, Phaser.Easing.Linear.Out, true);
					return;
				}

				wrongTween.to({ alpha: 0 }, 200, Phaser.Easing.Linear.Out, true, 100, 0, false);
				wrongTween.onComplete.add(function () {
					service.game.time.events.add(200, function () {
						self.arrows[indexAsset].alpha = 1;
					}, self);
					
				}, this);
				service.game.add.tween(sprite).to({ x: drag.x, y: drag.y }, 200, Phaser.Easing.Linear.Out, true);
			}

			if (service.answerObjects.length != service.totalCounter || service.done) { return; }

            service.updateUserProgress(service.totalCounter, service.rightAnswers);
		}
	};
});